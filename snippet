{
	
	"testcase": {
		"prefix": "tst",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#include <ext/pb_ds/assoc_container.hpp> ",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "#define rep(i,a,b) for (int i = a; i < b; i++)",
		  "#define mp make_pair",
		  "#define pii pair<int,int> ",
		  "#define pll pair<long long, long long>",
		  "#define pb push_back",
		  "#define fi first",
		  "#define se second",
		  "#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)",
		  "using namespace std;",
		  "using namespace __gnu_pbds;",
		  "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;",
		  "typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;"
		  "typedef vector<int> vi;",
		  "typedef vector<string> vs;",
		  "typedef vector<long long> vll;",
		  "typedef long long ll;",
		  "typedef long double ld;",
		  "ll mod = 1000000007;",
		  "const int N = 200000;",
		  "const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};", 
		  "const char dir[4]{'D','R','U','L'};",
		  "#define all(x) begin(x), end(x)",
		  "string yes = \"YES\\n\";",
		  "string no = \"NO\\n\";",
		  "int inf = 1e9;",
		  "",
		  "void test()",
		  "{",
		  "     ",
		  "}",
		  "",
		  "int main()",
		  "{",
		  "   speedboost;",
		  "   int t;",
		  "   cin >> t;",
		  "   rep(i,0,t) test();",
		  "}"
		],
		"description": "testcase"
	  },

	  "normal": {
		"prefix": "qa",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#include <ext/pb_ds/assoc_container.hpp> ",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "#define rep(i,a,b) for (int i = a; i < b; i++)",
		  "#define mp make_pair",
		  "#define pii pair<int,int> ",
		  "#define pb push_back",
		  "#define pll pair<long long, long long>",
		  "#define fi first",
		  "#define se second",
		  "#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)",
		  "using namespace std;",
		  "using namespace __gnu_pbds;",
		  "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;",
		  "typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;"
		  "typedef vector<int> vi;",
		  "typedef vector<string> vs;",
		  "typedef vector<long long> vll;",
		  "typedef long long ll;",
		  "typedef long double ld;",
		  "ll mod = 1000000007;",
		  "const int N = 200000;",
		  "const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};", 
		  "const char dir[4]{'D','R','U','L'};",
		  "#define all(x) begin(x), end(x)",
		  "string yes = \"YES\\n\";",
		  "string no = \"NO\\n\";",
		  "int inf = 1e9;",
		  "",
		  "int main()",
		  "{",
		  "    speedboost;",
		  "    ",
		  "}"
		],
		"description": "normal"
	  },
	  "ez format": {
		"prefix": "fmtsimple",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)",
		  "using namespace std;",
		  "typedef long long ll;",
		  "",
		  "int main()",
		  "{",
		  "    speedboost;",
		  "    ",
		  "}"
		],
		"description": "format "
	  },
	  "fenwick tree": {
		"prefix": "fft",
		"body": [
		  "struct FenwickTree {",
		  "    vector<int> bit;  // binary indexed tree",
		  "    int n;",
		  "",
		  "    FenwickTree(int n) {",
		  "        this->n = n;",
		  "        bit.assign(n, 0);",
		  "    }",
		  "",
		  "    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {",
		  "        for (size_t i = 0; i < a.size(); i++)",
		  "            add(i, a[i]);",
		  "    }",
		  "",
		  "    int sum(int r) {",
		  "        int ret = 0;",
		  "        for (; r >= 0; r = (r & (r + 1)) - 1)",
		  "            ret += bit[r];",
		  "        return ret;",
		  "    }",
		  "",
		  "    int sum(int l, int r) {",
		  "        return sum(r) - sum(l - 1);",
		  "    }",
		  "",
		  "    void add(int idx, int delta) {",
		  "        for (; idx < n; idx = idx | (idx + 1))",
		  "            bit[idx] += delta;",
		  "    }",
		  "};"
		],
		"description": "fenwick tree"
	  },
	  "binaryexpo": {
		"prefix": "binexpo",
		"body": [
		  "",
		  "ll power(ll base, ll ex)",
		  "{",
		  "    ll res = 1;",
		  "    ll x = base;",
		  "    ll y = ex;",
		  "    while (y > 0)",
		  "    {",
		  "        if (y & 1)",
		  "        {",
		  "            y--;",
		  "            res *= x;",
		  "            res %= mod;",
		  "        }",
		  "        else",
		  "        {",
		  "            y >>= 1;",
		  "            x = x* x;",
		  "            x %= mod;",
		  "        }",
		  "    }",
		  "    return res;",
		  "}",
		  " "
		],
		"description": "binaryexpo"
	  },
	  "sievefmt": {
		"prefix": "sievefmt",
		"body": [
		  "vector<bool> prime(N + 1, true);",
		  "vector<int> primes;",
		  "int pn;",
		  " ",
		  "void sieve()",
		  "{",
		  "    prime[1] = false;",
		  "    prime[0] = false;",
		  "     for (int p = 2; p * p <= N; p++)",
		  "     {",
		  "          if (prime[p])",
		  "          {",
		  "               for (int i = p * p; i <= N; i += p)",
		  "               {",
		  "                    prime[i] = false;",
		  "               }",
		  "          }",
		  "     }",
		  "     for (int i = 2; i <= N; i++)",
		  "     {",
		  "          if (prime[i])",
		  "          {",
		  "               primes.push_back(i);",
		  "          }",
		  "     }",
		  "     pn = primes.size();",
		  "}",
		  ""
		],
		"description": "sievefmt"
	  },
	  "combinatorics": {
		"prefix": "combfmt",
		"body": [
		  "vll fac(N + 1, 1);",
		  "",
		  "ll power(ll base, ll ex)",
		  "{",
		  "    ll res = 1;",
		  "    ll x = base;",
		  "    ll y = ex;",
		  "    while (y > 0)",
		  "    {",
		  "        if (y & 1)",
		  "        {",
		  "            y--;",
		  "            res *= x;",
		  "            res %= mod;",
		  "        }",
		  "        else",
		  "        {",
		  "            y >>= 1;",
		  "            x = x* x;",
		  "            x %= mod;",
		  "        }",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "ll inverse(ll x)",
		  "{",
		  "    return power(x, mod - 2);",
		  "}",
		  " ",
		  "ll binomial(int n, int k) {",
		  "    return fac[n] * inverse(fac[k] * fac[n - k] % mod) % mod;",
		  "}",
		  "",
		  "void cntfac()",
		  "{",
		  "    for (int i = 2; i <= N; i++)",
		  "    {",
		  "        fac[i] = fac[i - 1] * i;",
		  "        fac[i] %= mod;",
		  "    }",
		  "}"
		],
		"description": "combinatorics"
	  },
	  "segment tree": {
		"prefix": "segtreefmt",
		"body": [
		  "vll st(4 * N);",
		  " ",
		  "void build(ll node, ll start, ll end)",
		  "{",
		  "    if (start == end)",
		  "    {",
		  "        st[node] = a[start];",
		  "    }",
		  "    else",
		  "    {",
		  "        ll mid = (start + end) / 2;",
		  "        build(2 * node, start, mid);",
		  "        build(2 * node + 1, mid + 1, end);",
		  "        st[node ] = max(st[2 * node ], st[2 * node + 1]);",
		  "    }",
		  "}",
		  " ",
		  "void update(ll node, ll start, ll end,ll idx, ll val)",
		  "{",
		  "    if (start == end)",
		  "    {",
		  "        a[idx] = val;",
		  "        st[node] = val;",
		  "    }",
		  "    else",
		  "    {",
		  "        ll mid = (start + end) / 2;",
		  "        if (start <= idx && idx <= mid)",
		  "        {",
		  "            update(2 * node, start, mid, idx, val);",
		  "        }",
		  "        else",
		  "        {",
		  "            update(2 * node + 1, mid + 1, end, idx, val);",
		  "        }",
		  "        st[node] = max(st[2 * node], st[2 * node + 1]);",
		  "    }",
		  "}",
		  "",
		  "ll query(ll node, ll start, ll end, ll l, ll r)",
		  "{",
		  "    if (r < start || l > end)",
		  "    {",
		  "        return 0;",
		  "    }",
		  "    if (l <= start && end <= r)",
		  "    {",
		  "        return st[node];",
		  "    }",
		  "    ll mid = (start + end) / 2;",
		  "    ll p1 = query(2 * node, start, mid, l, r);",
		  "    ll p2 = query(2 * node + 1, mid + 1, end, l ,r);",
		  "    return max(p1 , p2);",
		  "}",
		  " "
		],
		"description": "segment tree"
	  },
	  "trie": {
		"prefix": "triefmt",
		"body": [
		  "const int K = 26;",
		  "",
		  "class node ",
		  "{",
		  "    public:",
		  "        std::vector<node*> child;",
		  "        bool end;",
		  "",
		  "        TrieNode() : end(false), child(K, nullptr) {}",
		  "};",
		  "",
		  "class Trie ",
		  "{",
		  "    public:",
		  "        node* root;",
		  "",
		  "        Trie() ",
		  "        {",
		  "            root = new TrieNode();",
		  "        }",
		  "",
		  "        void insert(string word) ",
		  "        {",
		  "            node* cur = root;",
		  "            for (char c : word) {",
		  "                int index = c - 'a';",
		  "                if (cur->child[index] == nullptr) ",
		  "                {",
		  "                    cur->child[index] = new TrieNode();",
		  "                }",
		  "                cur = cur->child[index];",
		  "            }",
		  "            cur->end = true;",
		  "        }",
		  "",
		  "        bool search(string word)",
		  "        {",
		  "            node* cur = root;",
		  "            for (char c : word) {",
		  "                int index = c - 'a';",
		  "                if (cur->child[index] == nullptr) ",
		  "                {",
		  "                    return false;",
		  "                }",
		  "                cur = cur->child[index];",
		  "            }",
		  "            return cur->end;",
		  "        }",
		  "",
		  "        bool startsWith(string prefix) ",
		  "        {",
		  "            node* cur = root;",
		  "            for (char c : prefix) ",
		  "            {",
		  "                int index = c - 'a';",
		  "                if (cur->child[index] == nullptr) ",
		  "                {",
		  "                    return false;",
		  "                }",
		  "                cur = cur->child[index];",
		  "            }",
		  "            return true;",
		  "        }",
		  "};",
		  ""
		],
		"description": "trie"
	  },
	  "tree problem fmt": {
		"prefix": "treetst",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#include <ext/pb_ds/assoc_container.hpp> ",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "#define rep(i,a,b) for (int i = a; i < b; i++)",
		  "#define mp make_pair",
		  "#define pii pair<int,int> ",
		  "#define pll pair<long long, long long>",
		  "#define pb push_back",
		  "#define fi first",
		  "#define se second",
		  "#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)",
		  "using namespace std;",
		  "using namespace __gnu_pbds;",
		  "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;",
		  "typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
		  "typedef vector<int> vi;",
		  "typedef vector<string> vs;",
		  "typedef vector<long long> vll;",
		  "typedef long long ll;",
		  "typedef long double ld;",
		  "ll mod = 1000000007;",
		  "const int N = 200000;",
		  "const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};",
		  "const char dir[4]{'D','R','U','L'};",
		  "#define all(x) begin(x), end(x)",
		  "string yes = \"YES\\n\";",
		  "string no = \"NO\\n\";",
		  "int inf = 1e9;",
		  "int n;",
		  "vector<vector<int>> adj(N + 1);",
		  "",
		  "void dfs(int v, int par)",
		  "{",
		  "    for (auto x : adj[v])",
		  "    {",
		  "        if (x != par)",
		  "        {",
		  "            dfs(x, v);",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "void reset()",
		  "{",
		  "    for (int i = 1; i <= n; i++)",
		  "    {",
		  "        adj[i].clear();",
		  "    }",
		  "}",
		  "",
		  "void test()",
		  "{",
		  "    cin >> n; ",
		  "    reset();",
		  "    for (int i = 1; i < n; i++)",
		  "    {",
		  "        int u, v;",
		  "        cin >> u >> v;",
		  "        adj[u].pb(v);",
		  "        adj[v].pb(u);",
		  "    }",
		  "}",
		  "",
		  "int main()",
		  "{",
		  "   speedboost;",
		  "   int t;",
		  "   cin >> t;",
		  "   rep(i,0,t) test();",
		  "}"
		],
		"description": "tree problem fmt"
	  },
	  "bitwise stuff": {
		"prefix": "bitmaskfmt",
		"body": [
			"const int B = 29;",
			" ",
			"int highbit(int x)",
			"{",
			"    // change to 63 for long long",
			"    return (31 - __builtin_clz(x));",
			"}",
			""
		],
		"description": "bitwise stuff"
		},
		"dsu": {
		"prefix": "dsufmt",
		"body": [
			"vector<int> par(N + 1);",
			"int n, m;",
			"int find(int x)",
			"{",
			"    if (par[x] == x) return x;",
			"    else",
			"    {",
			"        int p = find(par[x]);",
			"        par[x] = p;",
			"        return p;",
			"    }",
			"}",
			" ",
			"void unite(int x, int y)",
			"{",
			"    x = find(x); y = find(y);",
			"    par[y] = x;",
			"}",
			"",
			"void reset()",
			"{",
			"    for (int i = 1; i <= n; i++)",
			"    {",
			"        par[i] = i;",
			"    }",
			"}"
		],
		"description": "dsu"
		},
		"randomizer": {
  "prefix": "randfmt",
  "body": [
    "// srand(chrono::steady_clock::now().time_since_epoch().count());   ",
    "int rand(int a, int b)",
    "{",
    "    return a + rand() % (b - a + 1);",
    "}",
    ""
  ],
  "description": "randomizer"
}
}
