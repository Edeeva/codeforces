{
	
	"testcase": {
		"prefix": "tst",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#include <ext/pb_ds/assoc_container.hpp> ",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "#define rep(i,a,b) for (int i = a; i < b; i++)",
		  "#define mp make_pair",
		  "#define pii pair<int,int> ",
		  "#define pll pair<long long, long long>",
		  "#define pb push_back",
		  "#define fi first",
		  "#define se second",
		  "#define blahaj ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)",
		  "using namespace std;",
		  "using namespace __gnu_pbds;",
		  "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;",
		  "typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
		  "typedef vector<int> vi;",
		  "typedef vector<string> vs;",
		  "typedef vector<long long> vll;",
		  "typedef long long ll;",
		  "typedef long double ld;",
		  "ll mod = 1000000007;",
		  "const int N = 200000;",
		  "const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};", 
		  "const char dir[4]{'D','R','U','L'};",
		  "#define all(x) begin(x), end(x)",
		  "string yes = \"YES\\n\";",
		  "string no = \"NO\\n\";",
		  "int inf = 1e9;",
		  "",
		  "void test()",
		  "{",
		  "    ",
		  "}",
		  "",
		  "int main()",
		  "{",
		  "    blahaj;",
		  "    int t;",
		  "    cin >> t;",
		  "    rep(i,0,t) test();",
		  "}"
		],
		"description": "testcase"
	  },

	  "normal": {
		"prefix": "qa",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#include <ext/pb_ds/assoc_container.hpp> ",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "#define rep(i,a,b) for (int i = a; i < b; i++)",
		  "#define mp make_pair",
		  "#define pii pair<int,int> ",
		  "#define pb push_back",
		  "#define pll pair<long long, long long>",
		  "#define fi first",
		  "#define se second",
		  "#define blahaj ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)",
		  "using namespace std;",
		  "using namespace __gnu_pbds;",
		  "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;",
		  "typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
		  "typedef vector<int> vi;",
		  "typedef vector<string> vs;",
		  "typedef vector<long long> vll;",
		  "typedef long long ll;",
		  "typedef long double ld;",
		  "ll mod = 1000000007;",
		  "const int N = 200000;",
		  "const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};", 
		  "const char dir[4]{'D','R','U','L'};",
		  "#define all(x) begin(x), end(x)",
		  "string yes = \"YES\\n\";",
		  "string no = \"NO\\n\";",
		  "int inf = 1e9;",
		  "",
		  "int main()",
		  "{",
		  "    blahaj;",
		  "    ",
		  "}"
		],
		"description": "normal"
	  },
	  "ez format": {
		"prefix": "fmtsimple",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#define blahaj ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)",
		  "using namespace std;",
		  "typedef long long ll;",
		  "",
		  "int main()",
		  "{",
		  "    blahaj;",
		  "    ",
		  "}"
		],
		"description": "format "
	  },
	  "fenwick tree": {
		"prefix": "fft",
		"body": [
		  "struct FenwickTree {",
		  "    vector<int> bit;  // binary indexed tree",
		  "    int n;",
		  "",
		  "    FenwickTree(int n) {",
		  "        this->n = n;",
		  "        bit.assign(n, 0);",
		  "    }",
		  "",
		  "    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {",
		  "        for (size_t i = 0; i < a.size(); i++)",
		  "            add(i, a[i]);",
		  "    }",
		  "",
		  "    int sum(int r) {",
		  "        int ret = 0;",
		  "        for (; r >= 0; r = (r & (r + 1)) - 1)",
		  "            ret += bit[r];",
		  "        return ret;",
		  "    }",
		  "",
		  "    int sum(int l, int r) {",
		  "        return sum(r) - sum(l - 1);",
		  "    }",
		  "",
		  "    void add(int idx, int delta) {",
		  "        for (; idx < n; idx = idx | (idx + 1))",
		  "            bit[idx] += delta;",
		  "    }",
		  "};"
		],
		"description": "fenwick tree"
	  },
	  "binaryexpo": {
		"prefix": "binexpo",
		"body": [
		  "",
		  "ll power(ll base, ll ex)",
		  "{",
		  "    ll res = 1;",
		  "    ll x = base;",
		  "    ll y = ex;",
		  "    while (y > 0)",
		  "    {",
		  "        if (y & 1)",
		  "        {",
		  "            y--;",
		  "            res *= x;",
		  "            res %= mod;",
		  "        }",
		  "        else",
		  "        {",
		  "            y >>= 1;",
		  "            x = x* x;",
		  "            x %= mod;",
		  "        }",
		  "    }",
		  "    return res;",
		  "}",
		  " "
		],
		"description": "binaryexpo"
	  },
	  "sievefmt": {
		"prefix": "sievefmt",
		"body": [
		  "vector<bool> prime(N + 1, true);",
		  "vector<int> primes;",
		  "int pn;",
		  " ",
		  "void sieve()",
		  "{",
		  "    prime[1] = false;",
		  "    prime[0] = false;",
		  "     for (int p = 2; p * p <= N; p++)",
		  "     {",
		  "          if (prime[p])",
		  "          {",
		  "               for (int i = p * p; i <= N; i += p)",
		  "               {",
		  "                    prime[i] = false;",
		  "               }",
		  "          }",
		  "     }",
		  "     for (int i = 2; i <= N; i++)",
		  "     {",
		  "          if (prime[i])",
		  "          {",
		  "               primes.push_back(i);",
		  "          }",
		  "     }",
		  "     pn = primes.size();",
		  "}",
		  ""
		],
		"description": "sievefmt"
	  },
	  "combinatorics": {
		"prefix": "combfmt",
		"body": [
		  "vll fac(N + 1, 1);",
		  "",
		  "ll power(ll base, ll ex)",
		  "{",
		  "    ll res = 1;",
		  "    ll x = base;",
		  "    ll y = ex;",
		  "    while (y > 0)",
		  "    {",
		  "        if (y & 1)",
		  "        {",
		  "            y--;",
		  "            res *= x;",
		  "            res %= mod;",
		  "        }",
		  "        else",
		  "        {",
		  "            y >>= 1;",
		  "            x = x* x;",
		  "            x %= mod;",
		  "        }",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "ll inverse(ll x)",
		  "{",
		  "    return power(x, mod - 2);",
		  "}",
		  " ",
		  "ll binomial(int n, int k) {",
		  "    return fac[n] * inverse(fac[k] * fac[n - k] % mod) % mod;",
		  "}",
		  "",
		  "void cntfac()",
		  "{",
		  "    for (int i = 2; i <= N; i++)",
		  "    {",
		  "        fac[i] = fac[i - 1] * i;",
		  "        fac[i] %= mod;",
		  "    }",
		  "}"
		],
		"description": "combinatorics"
	  },
	  "segment tree": {
		"prefix": "segtreefmt",
		"body": [
		  "ll st[4 * N];",
		  " ",
		  "void build(int node, int start, int end)",
		  "{",
		  "    if (start == end)",
		  "    {",
		  "        st[node] = a[start];",
		  "    }",
		  "    else",
		  "    {",
		  "        int mid = (start + end) / 2;",
		  "        build(2 * node, start, mid);",
		  "        build(2 * node + 1, mid + 1, end);",
		  "        st[node] = max(st[2 * node ], st[2 * node + 1]);",
		  "    }",
		  "}",
		  " ",
		  "void update(int node, int start, int end, int idx, int val)",
		  "{",
		  "    if (start == end)",
		  "    {",
		  "        a[idx] = val;",
		  "        st[node] = val;",
		  "    }",
		  "    else",
		  "    {",
		  "        int mid = (start + end) / 2;",
		  "        if (start <= idx && idx <= mid)",
		  "        {",
		  "            update(2 * node, start, mid, idx, val);",
		  "        }",
		  "        else",
		  "        {",
		  "            update(2 * node + 1, mid + 1, end, idx, val);",
		  "        }",
		  "        st[node] = max(st[2 * node], st[2 * node + 1]);",
		  "    }",
		  "}",
		  "",
		  "int query(int node, int start, int end, int l, int r)",
		  "{",
		  "    if (r < start || l > end)",
		  "    {",
		  "        return 0;",
		  "    }",
		  "    if (l <= start && end <= r)",
		  "    {",
		  "        return st[node];",
		  "    }",
		  "    int mid = (start + end) / 2;",
		  "    int p1 = query(2 * node, start, mid, l, r);",
		  "    int p2 = query(2 * node + 1, mid + 1, end, l ,r);",
		  "    return max(p1 , p2);",
		  "}",
		  " "
		],
		"description": "segment tree"
	  },
	  "trie": {
		"prefix": "triefmt",
		"body": [
		  "const int K = 26;",
		  "",
		  "class node ",
		  "{",
		  "    public:",
		  "        std::vector<node*> child;",
		  "        bool end;",
		  "",
		  "        node() : end(false), child(K, nullptr) {}",
		  "};",
		  "",
		  "class Trie ",
		  "{",
		  "    public:",
		  "        node* root;",
		  "",
		  "        Trie() ",
		  "        {",
		  "            root = new node();",
		  "        }",
		  "",
		  "        void insert(string word) ",
		  "        {",
		  "            node* cur = root;",
		  "            for (char c : word) {",
		  "                int index = c - 'a';",
		  "                if (cur->child[index] == nullptr) ",
		  "                {",
		  "                    cur->child[index] = new node();",
		  "                }",
		  "                cur = cur->child[index];",
		  "            }",
		  "            cur->end = true;",
		  "        }",
		  "",
		  "        bool search(string word)",
		  "        {",
		  "            node* cur = root;",
		  "            for (char c : word) {",
		  "                int index = c - 'a';",
		  "                if (cur->child[index] == nullptr) ",
		  "                {",
		  "                    return false;",
		  "                }",
		  "                cur = cur->child[index];",
		  "            }",
		  "            return cur->end;",
		  "        }",
		  "",
		  "        bool startsWith(string prefix) ",
		  "        {",
		  "            node* cur = root;",
		  "            for (char c : prefix) ",
		  "            {",
		  "                int index = c - 'a';",
		  "                if (cur->child[index] == nullptr) ",
		  "                {",
		  "                    return false;",
		  "                }",
		  "                cur = cur->child[index];",
		  "            }",
		  "            return true;",
		  "        }",
		  "};",
		  ""
		],
		"description": "trie"
	  },
	  "tree problem fmt": {
		"prefix": "treetst",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#include <ext/pb_ds/assoc_container.hpp> ",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "#define rep(i,a,b) for (int i = a; i < b; i++)",
		  "#define mp make_pair",
		  "#define pii pair<int,int> ",
		  "#define pll pair<long long, long long>",
		  "#define pb push_back",
		  "#define fi first",
		  "#define se second",
		  "#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)",
		  "using namespace std;",
		  "using namespace __gnu_pbds;",
		  "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;",
		  "typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
		  "typedef vector<int> vi;",
		  "typedef vector<string> vs;",
		  "typedef vector<long long> vll;",
		  "typedef long long ll;",
		  "typedef long double ld;",
		  "ll mod = 1000000007;",
		  "const int N = 200000;",
		  "const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};",
		  "const char dir[4]{'D','R','U','L'};",
		  "#define all(x) begin(x), end(x)",
		  "string yes = \"YES\\n\";",
		  "string no = \"NO\\n\";",
		  "int inf = 1e9;",
		  "int n;",
		  "vector<vector<int>> adj(N + 1);",
		  "",
		  "void dfs(int v, int par)",
		  "{",
		  "    for (auto x : adj[v])",
		  "    {",
		  "        if (x != par)",
		  "        {",
		  "            dfs(x, v);",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "void reset()",
		  "{",
		  "    for (int i = 1; i <= n; i++)",
		  "    {",
		  "        adj[i].clear();",
		  "    }",
		  "}",
		  "",
		  "void test()",
		  "{",
		  "    cin >> n; ",
		  "    reset();",
		  "    for (int i = 1; i < n; i++)",
		  "    {",
		  "        int u, v;",
		  "        cin >> u >> v;",
		  "        adj[u].pb(v);",
		  "        adj[v].pb(u);",
		  "    }",
		  "}",
		  "",
		  "int main()",
		  "{",
		  "   speedboost;",
		  "   int t;",
		  "   cin >> t;",
		  "   rep(i,0,t) test();",
		  "}"
		],
		"description": "tree problem fmt"
	  },
	  "bitwise stuff": {
		"prefix": "bitmaskfmt",
		"body": [
			"const int B = 29;",
			" ",
			"int highbit(int x)",
			"{",
			"    // change to 63 for long long",
			"    return (31 - __builtin_clz(x));",
			"}",
			""
		],
		"description": "bitwise stuff"
		},
		"dsu": {
		"prefix": "dsufmt",
		"body": [
			"vector<int> par(N + 1);",
			"int n, m;",
			"int find(int x)",
			"{",
			"    if (par[x] == x) return x;",
			"    else",
			"    {",
			"        int p = find(par[x]);",
			"        par[x] = p;",
			"        return p;",
			"    }",
			"}",
			" ",
			"void unite(int x, int y)",
			"{",
			"    x = find(x); y = find(y);",
			"    par[y] = x;",
			"}",
			"",
			"void reset()",
			"{",
			"    for (int i = 1; i <= n; i++)",
			"    {",
			"        par[i] = i;",
			"    }",
			"}"
		],
		"description": "dsu"
		},
		"randomizer": {
  "prefix": "randfmt",
  "body": [
    "// srand(chrono::steady_clock::now().time_since_epoch().count());   ",
    "int rand(int a, int b)",
    "{",
    "    return a + rand() % (b - a + 1);",
    "}",
    ""
  ],
  "description": "randomizer"
},
"The Town Inside Me": {
  "prefix": "thetowninsideme",
  "body": [
    "/*",
    "The town inside me and everyone's voice",
    "Only I'm not there, just watching from afar",
    "I can't go home because I'm afraid",
    "Something will change, me without me",
    "I'm the one to blame",
    "I've moved on, by my own will",
    "(I had nothing else I wanted to do)",
    "It wasn't hard, but I didn't hate it",
    "(I did not even like it)",
    "I've been patient, but it was bearable",
    "I've had a gray haze for a long time though (boom-boom)",
    "I never found out, what it was, I",
    "It's my stress, that's for sure",
    "I never wanted to run away",
    "(I was very motivated)",
    "Then what is this feeling?",
    "(Who would I ask?)",
    "I've been patient, but it was bearable",
    "I've had a gray haze for a long time though (boom-boom)",
    "I never found out, what it was, I",
    "Tastes like vegetables I don't like",
    "The town inside me and everyone's voice",
    "Only I'm not there, just watching from afar",
    "I can't go home because I'm afraid",
    "Something will change, me without me",
    "I'm the one to blame",
    "I'm not waiting (for a Santa Claus)",
    "I already have the gifts, just can't open the box",
    "(Just can't open the box)",
    "I know all about it, no one can stop it",
    "Unless I just had to do something 'bout it",
    "\"It's not even a case!\"",
    "I've been patient, but it was bearable",
    "I've had a gray haze for a long time though (boom-boom)",
    "I never found out, what it was, I",
    "I hate the alarm clock I chose",
    "The town inside me and everyone's voice",
    "Only I'm not there, just watching from afar",
    "I can't go home because I'm afraid",
    "Something will change, me without me",
    "I'm the one to blame",
    "I'm out of patience, my body is light",
    "Let's paint the gray haze into sky blue",
    "I know who you are!",
    "I'm not leaving you again!",
    "The town inside me and everyone's voice",
    "Only I'm not there, just watching from afar",
    "There is nowhere to go that, nowhere to go",
    "It's all just food y'know",
    "Me without me (I'm the one to blame)",
    "The night falls, the place where I belong",
    "No matter what changes, will no longer change me",
    "No matter what (change), no, no, no, won't change me",
    "I can feel the light, even after the sun goes down",
    "*/"
  ],
  "description": "The Town Inside Me"
},
"put mt19937 on main": {
  "prefix": "rngfmt",
  "body": [
    "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "int rand(int a, int b) {",
    "    uniform_int_distribution<int> dist(a, b);",
    "    return dist(rng);",
    "}"
  ],
  "description": "put mt19937 on main"
},
"": {
  "prefix": "hel",
  "body": [
    "hello worldddddddddddddddddd"
  ],
  "description": ""
},
"sparse table": {
  "prefix": "sparsefmt",
  "body": [
    "int n;",
    "const int LOG = 20;",
    "int sp[N + 1][LOG + 1];",
    "int a[N + 1];",
    "",
    "int highbit(int x)",
    "{",
    "    return (31 - __builtin_clz(x));",
    "}",
    "",
    "int query(int l, int r)",
    "{",
    "    int len = r - l + 1;",
    "    int k = highbit(len);",
    "    return max(sp[l][k], sp[r - (1<<k) + 1][k]);",
    "}",
    "",
    "void build()",
    "{",
    "    for (int i = 1; i <= n; i++) sp[i][0] = a[i];",
    "    for (int j = 1; j <= LOG; j++)",
    "    {",
    "        for (int i = 1; i + (1<<j) - 1 <= n; i++)",
    "        {",
    "            sp[i][j] = max(sp[i][j - 1], sp[i + (1<<(j - 1))][j - 1]);",
    "        }",
    "    }",
    "}"
  ],
  "description": "sparse table"
},
"lazy propagation": {
  "prefix": "lazysegtreefmt",
  "body": [
    "",
    "int st[4 * N];",
    "int lazy[4 * N];",
    " ",
    "int mergenode(int p1, int p2)",
    "{",
    "    return min(p1, p2);",
    "}",
    "",
    "void build(int node, int start, int end) {",
    "    lazy[node] = 0;",
    "    if (start == end) {",
    "        st[node] = inf;",
    "    } else {",
    "        int mid = (start + end) / 2;",
    "        build(2 * node, start, mid);",
    "        build(2 * node + 1, mid + 1, end);",
    "        st[node] = mergenode(st[2 * node], st[2 * node + 1]);",
    "    }",
    "}",
    " ",
    "void propagate(int node, int start, int end) {",
    "    if (lazy[node] != 0) {",
    "        st[node] += lazy[node]; ",
    "        ",
    "        if (start != end) {",
    "            lazy[2 * node] += lazy[node];",
    "            lazy[2 * node + 1] += lazy[node];",
    "        }",
    "        lazy[node] = 0;",
    "    }",
    "}",
    " ",
    "void update(int node, int start, int end, int l, int r, int val) {",
    "    propagate(node, start, end);",
    "    if (r < start || end < l) {",
    "        return;",
    "    }",
    "    ",
    "    if (l <= start && end <= r) {",
    "        lazy[node] += val;",
    "        propagate(node, start, end);",
    "        return;",
    "    }",
    "    ",
    "    int mid = (start + end) / 2;",
    "    update(2 * node, start, mid, l, r, val);",
    "    update(2 * node + 1, mid + 1, end, l, r, val);",
    "    ",
    "    st[node] = mergenode(st[2 * node], st[2 * node + 1]);",
    "}",
    " ",
    "int query(int node, int start, int end, int l, int r) {",
    "    propagate(node, start, end);",
    "    if (r < start || end < l) {",
    "        return inf;",
    "    }",
    "    if (l <= start && end <= r) {",
    "        return st[node];",
    "    }",
    "    int mid = (start + end) / 2;",
    "    int p1 = query(2 * node, start, mid, l, r);",
    "    int p2 = query(2 * node + 1, mid + 1, end, l, r);",
    "    return mergenode(p1, p2);",
    "}",
    " ",
    "void setvalue(int node, int start, int end, int idx, int val)",
    "{",
    "    propagate(node, start, end);",
    "    if (start == end)",
    "    {",
    "        lazy[node] = 0;",
    "        st[node] = val;",
    "        return; ",
    "    }",
    "    int mid = (start + end) / 2;",
    "    if (idx <= mid) setvalue(2 * node, start, mid, idx, val);",
    "    else setvalue(2 * node + 1, mid + 1, end, idx, val);",
    "    propagate(2 * node, start, mid);",
    "    propagate(2 * node + 1, mid + 1, end);",
    "    st[node] = mergenode(st[2 * node], st[2 * node + 1]);",
    "}"
  ],
  "description": "lazy propagation"
},
"pragmaas": {
  "prefix": "pragmafmt",
  "body": [
    "#pragma GCC optimize(\"O3,unroll-loops\")",
    "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
  ],
  "description": "pragmaas"
},
"Extended GCD": {
  "prefix": "exgcdfmt",
  "body": [
    "ll extended_gcd(ll a, ll b, ll &x, ll &y) {",
    "    if (b == 0) {",
    "        x = 1;",
    "        y = 0;",
    "        return a;",
    "    }",
    "    ll x1, y1;",
    "    ll gcd = extended_gcd(b, a % b, x1, y1);",
    "    x = y1;",
    "    y = x1 - (a / b) * y1;",
    "    return gcd;",
    "}",
    " ",
    "ll mod_inverse(ll a, ll m) {",
    "    ll x, y;",
    "    ll gcd = extended_gcd(a, m, x, y);",
    "    if (gcd != 1) {",
    "        return -1;",
    "    }",
    "    ll inv = (x % m + m) % m;",
    "    return inv;",
    "}",
    " "
  ],
  "description": "Extended GCD"
},
"Manacher's Algorithm": {
  "prefix": "manacherfmt",
  "body": [
    "vector<int> manacher(string s) { // edeeva tries to implement manacher and fails horribly",
    "    string a = \"\";",
    "    for (auto c : s) {",
    "        a.pb('#');",
    "        a.pb(c);",
    "    }",
    "    a.pb('#');",
    "    int last = -1;",
    "    int r = -1;",
    "    int n = a.size();",
    "    vector<int> p(n, 0);",
    "    for (int i = 0; i < n; i++)",
    "    {",
    "        bool center = false;",
    "        int start = 0;",
    "        if (i > r) center = true;",
    "        else",
    "        {",
    "            int maxgo = r - i;",
    "            int j = 2 * last - i;",
    "            if (p[j] > maxgo)",
    "            {",
    "                p[i] = maxgo;",
    "            }",
    "            else if (p[j] < maxgo)",
    "            {",
    "                p[i] = p[j];",
    "            }",
    "            else",
    "            {",
    "                start = maxgo;",
    "                center = true;",
    "            }",
    "        }",
    "        if (center)",
    "        {",
    "            p[i] = start;",
    "            while (i - p[i] - 1 >= 0 && i + p[i] + 1 < n && a[i - p[i] - 1] == a[i + p[i] + 1]) p[i]++;",
    "            r = i + p[i];",
    "            last = i;",
    "        }",
    "    }",
    "    /*",
    "    how to use (1 <= i <= n, so i is 1-indexed)",
    "    p[i * 2 - 1] = longest palindrome by making s[i] center",
    "    p[i * 2] = longest palindrome by making s[i] & s[i + 1] center (even length) ",
    "    */",
    "    return p;",
    "}"
  ],
  "description": "Manacher's Algorithm"
}
}
